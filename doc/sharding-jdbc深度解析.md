https://mp.weixin.qq.com/s/W-pBQInQKu99NLn2rHMI-Q?

#### sql 路由
SQL路由是根据分片规则配置以及解析上下文中的分片条件，将SQL定位至真正的数据源。它又分为直接路由、简单路由和笛卡尔积路由。  

直接路由: hint方式分片，且仅分库，无需SQL解析和结果归并。
简单路由: 是指不包含JOIN或仅包含Binding表JOIN的SQL。  
          Binding表是指使用同样的分片键和分片规则的一组表,也就是说任何情况下，Binding表的分片结果应与主表一致。例如：order表和order_item表，都根据order_id分片，结果应是order_1与order_item_1成对出现。这样的关联查询和单表查询复杂度和性能相当。  
          如果分片条件不是等于，而是BETWEEN或IN，则路由结果不一定落入单库（表），因此一条逻辑SQL最终可能拆分为多条SQL语句。  
          
笛卡尔积查询: 无法根据Binding关系定位分片规则的一致性，所以非Binding表的关联查询需要拆解为笛卡尔积组合执行。查询性能较低，而且数据库连接数较高，需谨慎使用。  


#### sql 改写
SQL改写分为正确性改写和优化改写两部分。

#### sql执行
路由至真实数据源后，Sharding -JDBC将采用多线程并发执行SQL。
它用3种执行引擎分别对应处理Statement，PreparedStatement和AddBatchPreparedStatement。Sharding-JDBC线程池放在一个名为ShardingContext的对象中，
它的生命周期同ShardingDataSource保持一致。如果一个应用中创建了多个Sharding-JDBC的数据源，它们将持有不同的线程池。


#### 结果归并
功能上:遍历，排序，分组，分页  
结构上：流式归并，内存归并，装饰者归并  

遍历和排序都是流式归并  
分组分为流式分组和内存分组  

流式归并是将数据游标与结果集的游标保持一致，顺序的从结果集中一条条的获取正确的数据。  
内存归并则是需要将结果集的所有数据都遍历并存储在内存中，再通过内存归并后，将内存中的数据伪装成结果集返回。

遍历类型最为简单，只需将多结果集组成链表，遍历完成当前结果集后，将链表位置后移，继续遍历下一个结果集即可。  

排序:Sharding-JDBC在排序类型归并时，将每个结果集的当前排序数据实现了比较器，并将其放入优先级队列。每次JDBC调用next时，将队列顶端的结果集出队并next，然后获取新的队列顶端的结果集供JDBC获取数据。

分组：分组归并分成流式分组归并和内存分组归并  
流式分组归并节省内存，但必须要求排序和分组的数据保持一致。如果GROUPBY和ORDER BY的内容不一致，则必须使用内存分组归并。  
由于数据不是按照分组需要的顺序取出，因此需要将结果集中的所有数据全部加载至内存。在SQL改写时提到的仅有GROUP BY的SQL，会优化增加ORDER BY语句，即使将内存分组归并优化为流式分组归并的提升。

分页：装饰者归并  
分页归并会将改写的LIMIT中，不需要获取的数据过滤掉。
Sharding-JDBC的分页很容易产生误解，很多人认为分页会占用大量内存，因为Sharding-JDBC会因为分布式正确性的考量，将LIMIT 100000, 10改写为LIMIT 0, 100010，产生Sharding-JDBC会将100010数据都加载到内存的错觉。
通过上面分析可知，会全部加载到内存的只有内存分组归并这一种情况。
其他情况都是通过流式获取结果集数据的方式，因此Sharding-JDBC会通过结果集的next方法将无需取出的数据全部跳过，并不会将其存入内存。
